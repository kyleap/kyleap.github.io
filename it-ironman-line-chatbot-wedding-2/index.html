<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>用.NET Core接收第一個Line訊息 (2) | 凱哥打扣 | Kyle Studio</title>
<meta name=keywords content="Chatbot"><meta name=description content="基本設定 關於如何註冊一個串接自己Web Api 的 Line Chatbot 網路上已經很多的教學文了，大概分為以下幾個步驟
https://developers.line.biz/en/
申請一個Provider 申請一個Channel (一個Provider可以有多個Channel) 於Channel取得 Channel Secret 及 Access Token Use webhook 啟用 Auto-reply messages 關閉 設定 Webhook URL (需為https) 起始 Web API 專案與 Line Server 做連結 建立一個 .NET Core 3.1 的 Web Api 專案
建立一個 Line Controller，先用 dynamic 接收，看看 Request 過來的是什麼
執行看看，weatherforecast 為初始專案的 Sample，此Local Api 的 Port 為 44300
透過 ngrok 讓 Line Server 跟 Local Web API 做連結
安裝 node.js npm install ngrok -g ngrok -v 本文章所使用的版本為 2."><meta name=author content="Kyle"><link rel=canonical href=https://kyleap.github.io/it-ironman-line-chatbot-wedding-2/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://kyleap.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kyleap.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kyleap.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://kyleap.github.io/apple-touch-icon.png><link rel=mask-icon href=https://kyleap.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-DPE6YM5E5N"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DPE6YM5E5N",{anonymize_ip:!1})}</script><meta property="og:title" content="用.NET Core接收第一個Line訊息 (2)"><meta property="og:description" content="基本設定 關於如何註冊一個串接自己Web Api 的 Line Chatbot 網路上已經很多的教學文了，大概分為以下幾個步驟
https://developers.line.biz/en/
申請一個Provider 申請一個Channel (一個Provider可以有多個Channel) 於Channel取得 Channel Secret 及 Access Token Use webhook 啟用 Auto-reply messages 關閉 設定 Webhook URL (需為https) 起始 Web API 專案與 Line Server 做連結 建立一個 .NET Core 3.1 的 Web Api 專案
建立一個 Line Controller，先用 dynamic 接收，看看 Request 過來的是什麼
執行看看，weatherforecast 為初始專案的 Sample，此Local Api 的 Port 為 44300
透過 ngrok 讓 Line Server 跟 Local Web API 做連結
安裝 node.js npm install ngrok -g ngrok -v 本文章所使用的版本為 2."><meta property="og:type" content="article"><meta property="og:url" content="https://kyleap.github.io/it-ironman-line-chatbot-wedding-2/"><meta property="og:image" content="https://user-images.githubusercontent.com/8849818/227669578-aace96bd-bfb3-4cd5-9e52-52d8742ed597.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-02T07:31:45+00:00"><meta property="article:modified_time" content="2020-11-02T07:31:45+00:00"><meta property="og:site_name" content="凱哥打扣 | Kyle Studio"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://user-images.githubusercontent.com/8849818/227669578-aace96bd-bfb3-4cd5-9e52-52d8742ed597.jpg"><meta name=twitter:title content="用.NET Core接收第一個Line訊息 (2)"><meta name=twitter:description content="基本設定 關於如何註冊一個串接自己Web Api 的 Line Chatbot 網路上已經很多的教學文了，大概分為以下幾個步驟
https://developers.line.biz/en/
申請一個Provider 申請一個Channel (一個Provider可以有多個Channel) 於Channel取得 Channel Secret 及 Access Token Use webhook 啟用 Auto-reply messages 關閉 設定 Webhook URL (需為https) 起始 Web API 專案與 Line Server 做連結 建立一個 .NET Core 3.1 的 Web Api 專案
建立一個 Line Controller，先用 dynamic 接收，看看 Request 過來的是什麼
執行看看，weatherforecast 為初始專案的 Sample，此Local Api 的 Port 為 44300
透過 ngrok 讓 Line Server 跟 Local Web API 做連結
安裝 node.js npm install ngrok -g ngrok -v 本文章所使用的版本為 2."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kyleap.github.io/posts/"},{"@type":"ListItem","position":2,"name":"用.NET Core接收第一個Line訊息 (2)","item":"https://kyleap.github.io/it-ironman-line-chatbot-wedding-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"用.NET Core接收第一個Line訊息 (2)","name":"用.NET Core接收第一個Line訊息 (2)","description":"基本設定 關於如何註冊一個串接自己Web Api 的 Line Chatbot 網路上已經很多的教學文了，大概分為以下幾個步驟\nhttps://developers.line.biz/en/\n申請一個Provider 申請一個Channel (一個Provider可以有多個Channel) 於Channel取得 Channel Secret 及 Access Token Use webhook 啟用 Auto-reply messages 關閉 設定 Webhook URL (需為https) 起始 Web API 專案與 Line Server 做連結 建立一個 .NET Core 3.1 的 Web Api 專案\n建立一個 Line Controller，先用 dynamic 接收，看看 Request 過來的是什麼\n執行看看，weatherforecast 為初始專案的 Sample，此Local Api 的 Port 為 44300\n透過 ngrok 讓 Line Server 跟 Local Web API 做連結\n安裝 node.js npm install ngrok -g ngrok -v 本文章所使用的版本為 2.","keywords":["Chatbot"],"articleBody":"基本設定 關於如何註冊一個串接自己Web Api 的 Line Chatbot 網路上已經很多的教學文了，大概分為以下幾個步驟\nhttps://developers.line.biz/en/\n申請一個Provider 申請一個Channel (一個Provider可以有多個Channel) 於Channel取得 Channel Secret 及 Access Token Use webhook 啟用 Auto-reply messages 關閉 設定 Webhook URL (需為https) 起始 Web API 專案與 Line Server 做連結 建立一個 .NET Core 3.1 的 Web Api 專案\n建立一個 Line Controller，先用 dynamic 接收，看看 Request 過來的是什麼\n執行看看，weatherforecast 為初始專案的 Sample，此Local Api 的 Port 為 44300\n透過 ngrok 讓 Line Server 跟 Local Web API 做連結\n安裝 node.js npm install ngrok -g ngrok -v 本文章所使用的版本為 2.3.35\n執行 ngrok http 44300 -host-header=”localhost:44300\" -region ap\n44300要替換成你本地執行Run起來的Port\n-region ap 為切換 ngrok 的 server，預設為us，在今年 Line 開始阻擋來至於 ngrok us 的 server 了，所以我們要將 Region 切到 Asia/Pacific (ap)\nRun 起來大概會長這樣\n我們將 https://44a914411bf2.ap.ngrok.io 這串加上Route api/line 後貼到 Line Developer Console，點選 Verify\n進入 http://127.0.0.1:4040/ ，可以看到Line Server POST 過來的 Request\n把這個POST 的 Body 移到 Postman 方便測試\n也可以直接用我建好的 Collection 匯入 https://www.getpostman.com/collections/8a93e0b6ce3ff66f8c8b\n透過 Postman 測試，在VS下中斷點，驗證可接收到\n驗證是否為有效的Line來源 API 有了，但我們要如何驗證這個 Request 是來自 Line Server 來阻擋惡意攻擊呢? 在 Line Server 所傳過來的 Header 會包含這個項目 **X-Line-Signature ，**將 POST Body 跟 Chanel Secret 用做 HMAC-SHA256 演算法Hash過後，比對過後如果相同，表示該 Request 是來自 Line Server\n*Verifying Signatures 官方參考文件*\n在 Web Api 實作，我們先新建一個 Authorization Filter 來驗證 Line Signature，.NET Core Web Api 的 Reuqest pipeline 如下：\n新增一個 Filter 叫 LineVerifySignatureFilter.cs 繼承 IAuthorizationFilter 實作，Channel Secret 要替換\npublic class LineVerifySignatureFilter : IAuthorizationFilter { public void OnAuthorization(AuthorizationFilterContext context) { /* * Ensure the requestBody can be read multiple times. * [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httprequestrewindextensions.enablebuffering?view=aspnetcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httprequestrewindextensions.enablebuffering?view=aspnetcore-3.1) */ context.HttpContext.Request.EnableBuffering(); string requestBody = new StreamReader(context.HttpContext.Request.Body).ReadToEndAsync().Result; context.HttpContext.Request.Body.Position = 0; var xLineSignature = context.HttpContext.Request.Headers[\"X-Line-Signature\"].ToString(); var channelSecret = Encoding.UTF8.GetBytes(\"{Channel Secret}\"); var body = Encoding.UTF8.GetBytes(requestBody); using (HMACSHA256 hmac = new HMACSHA256(channelSecret)) { var hash = hmac.ComputeHash(body, 0, body.Length); var xLineBytes = Convert.FromBase64String(xLineSignature); if (SlowEquals(xLineBytes, hash) == false) { context.Result = new ForbidResult(); } } } private static bool SlowEquals(byte[] a, byte[] b) { uint diff = (uint)a.Length ^ (uint)b.Length; for (int i = 0; i \u003c a.Length \u0026\u0026 i \u003c b.Length; i++) diff |= (uint)(a[i] ^ b[i]); return diff == 0; } } 新增一個 Line LineVerifySignatureAttribute.cs 透過 TypeFilterAttribute 來例化\npublic class LineVerifySignatureAttribute : TypeFilterAttribute { public LineVerifySignatureAttribute() : base(typeof(LineVerifySignatureFilter)) { } } 在 Line Api Route 加上 [LineVerifySignature] 進行驗證，這樣程式就乾淨多了\n把 Channel Secret/Access Token 移到 appsettings.json 通常我們會把這兩個資訊寫在設定檔，以便使用跟替換，在 .NET Core 可以使用 IOption 的方式來從設定檔注入\n在 appsettings.json 增加區塊，放Channel Secret/Access Token\n增加一個 LineSetting.cs，我們要用強型別來開發\nstartup.cs 增加 services.AddOptions()\n回到前面建立的 LineVerifySignatureFilter.cs，注入 LineSetting及使用 ChannelSecret 即可完成\n懶人包，本次學到了什麼? 如何申請一個 Line Chatbot - 參考上方6步驟 LINE Developers 如何建立一個 .NET Core Web Api 專案 Building Your First Web API with ASP.NET Core MVC and Visual Studio 用 CLI 建立 .NET Core 如何將 Web API 跟 Line Server 連結起來 Install ngrok by npm 如何驗證有效的Line Request Line Signature Validation 如何使用 .NET Core 的 Filters \u0026 Attributes Filters in ASP.NET Core 如何在.NET Core讀取設定檔 Options pattern in ASP.NET Core ","wordCount":"421","inLanguage":"en","datePublished":"2020-11-02T07:31:45Z","dateModified":"2020-11-02T07:31:45Z","author":[{"@type":"Person","name":"Kyle"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://kyleap.github.io/it-ironman-line-chatbot-wedding-2/"},"publisher":{"@type":"Organization","name":"凱哥打扣 | Kyle Studio","logo":{"@type":"ImageObject","url":"https://kyleap.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kyleap.github.io/ accesskey=h title="凱哥打扣 (Alt + H)">凱哥打扣</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kyleap.github.io/kyleshen/ title=about><span>about</span></a></li><li><a href=https://kyleap.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://kyleap.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://kyleap.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://kyleap.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kyleap.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://kyleap.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">用.NET Core接收第一個Line訊息 (2)</h1><div class=post-meta><span title='2020-11-02 07:31:45 +0000 UTC'>2020-11-02</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Kyle</div></header><div class=post-content><h1 id=基本設定>基本設定<a hidden class=anchor aria-hidden=true href=#基本設定>#</a></h1><p>關於如何註冊一個串接自己Web Api 的 Line Chatbot 網路上已經很多的教學文了，大概分為以下幾個步驟</p><p><a href=https://developers.line.biz/en/>https://developers.line.biz/en/</a></p><ul><li><input disabled type=checkbox> 申請一個Provider</li><li><input disabled type=checkbox> 申請一個Channel (一個Provider可以有多個Channel)</li><li><input disabled type=checkbox> 於Channel取得 Channel Secret 及 Access Token</li><li><input disabled type=checkbox> Use webhook 啟用</li><li><input disabled type=checkbox> Auto-reply messages 關閉</li><li><input disabled type=checkbox> 設定 Webhook URL (需為https)</li></ul><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*fjpJniJoXJftzkVONMHEgQ.png alt></p><h1 id=起始-web-api-專案與-line-server-做連結>起始 Web API 專案與 Line Server 做連結<a hidden class=anchor aria-hidden=true href=#起始-web-api-專案與-line-server-做連結>#</a></h1><p>建立一個 .NET Core 3.1 的 Web Api 專案</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2048/1*w6rqpw8HPRpTWwyugCE1ug.png alt></p><p>建立一個 Line Controller，先用 dynamic 接收，看看 Request 過來的是什麼</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*hawr2BDGabUvy-6PUoevYA.png alt></p><p>執行看看，weatherforecast 為初始專案的 Sample，此Local Api 的 Port 為 44300</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*YbcHzYJiF9Qo_00rUblY4g.png alt></p><p>透過 ngrok 讓 Line Server 跟 Local Web API 做連結</p><ol><li>安裝 <a href=https://nodejs.org/en/>node.js</a></li><li>npm install ngrok -g</li><li>ngrok -v</li></ol><p>本文章所使用的版本為 2.3.35</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*TUWEhgQhvUDmFT1QcKgAPA.png alt></p><blockquote><p>執行 ngrok http 44300 -host-header=”localhost:44300" -region ap</p></blockquote><p>44300要替換成你本地執行Run起來的Port</p><p>-region ap 為切換 ngrok 的 server，預設為us，在今年 Line 開始阻擋來至於 ngrok us 的 server 了，所以我們要將 Region 切到 Asia/Pacific (ap)</p><p>Run 起來大概會長這樣</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*5zTDNVVcq4vezCCke5FCRg.png alt></p><p>我們將 <a href=https://44a914411bf2.ap.ngrok.io>https://44a914411bf2.ap.ngrok.io</a> 這串加上Route api/line 後貼到 Line Developer Console，點選 Verify</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*Npfh7L_0Phpp54W9m31lpg.png alt></p><p>進入 <a href=http://127.0.0.1:4040/inspect/http>http://127.0.0.1:4040/</a> ，可以看到Line Server POST 過來的 Request</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2402/1*qilNfYn3cym3B77PZFF8OQ.png alt></p><p>把這個POST 的 Body 移到 Postman 方便測試</p><p>也可以直接用我建好的 Collection 匯入 <a href=https://www.getpostman.com/collections/8a93e0b6ce3ff66f8c8b>https://www.getpostman.com/collections/8a93e0b6ce3ff66f8c8b</a></p><p>透過 Postman 測試，在VS下中斷點，驗證可接收到</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*bDJTdnR-cNl7mbtQMWI6EA.png alt></p><h1 id=驗證是否為有效的line來源>驗證是否為有效的Line來源<a hidden class=anchor aria-hidden=true href=#驗證是否為有效的line來源>#</a></h1><p>API 有了，但我們要如何驗證這個 Request 是來自 Line Server 來阻擋惡意攻擊呢? 在 Line Server 所傳過來的 Header 會包含這個項目 **X-Line-Signature ，**將 POST Body 跟 Chanel Secret 用做 HMAC-SHA256 演算法Hash過後，比對過後如果相同，表示該 Request 是來自 Line Server</p><p><a href=https://developers.line.biz/en/docs/messaging-api/receiving-messages/#verifying-signatures>*Verifying Signatures 官方參考文件</a>*</p><p>在 Web Api 實作，我們先新建一個 Authorization Filter 來驗證 Line Signature，.NET Core Web Api 的 Reuqest pipeline 如下：</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2416/0*ZC8tbFU8ClATy2vR alt="https://docs.microsoft.com/zh-tw/aspnet/core/mvc/controllers/filters?view=aspnetcore-3.1"></p><p>新增一個 Filter 叫 LineVerifySignatureFilter.cs 繼承 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.web.mvc.iauthorizationfilter?view=aspnet-mvc-5.2">IAuthorizationFilter </a>實作，Channel Secret 要替換</p><pre tabindex=0><code>    public class LineVerifySignatureFilter : IAuthorizationFilter
    {
     public void OnAuthorization(AuthorizationFilterContext context)
     {
      /*
       * Ensure the requestBody can be read multiple times. 
       * [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httprequestrewindextensions.enablebuffering?view=aspnetcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httprequestrewindextensions.enablebuffering?view=aspnetcore-3.1)
       */
      context.HttpContext.Request.EnableBuffering();

    string requestBody = new StreamReader(context.HttpContext.Request.Body).ReadToEndAsync().Result;
      context.HttpContext.Request.Body.Position = 0;

    var xLineSignature = context.HttpContext.Request.Headers[&#34;X-Line-Signature&#34;].ToString();
      var channelSecret = Encoding.UTF8.GetBytes(&#34;{Channel Secret}&#34;);
      var body = Encoding.UTF8.GetBytes(requestBody);

    using (HMACSHA256 hmac = new HMACSHA256(channelSecret))
      {
       var hash = hmac.ComputeHash(body, 0, body.Length);
       var xLineBytes = Convert.FromBase64String(xLineSignature);
       if (SlowEquals(xLineBytes, hash) == false)
       {
        context.Result = new ForbidResult();
       }
      }
     }

    private static bool SlowEquals(byte[] a, byte[] b)
     {
      uint diff = (uint)a.Length ^ (uint)b.Length;
      for (int i = 0; i &lt; a.Length &amp;&amp; i &lt; b.Length; i++)
       diff |= (uint)(a[i] ^ b[i]);
      return diff == 0;
     }
    }
</code></pre><p>新增一個 Line LineVerifySignatureAttribute.cs 透過 <a href="https://docs.microsoft.com/zh-tw/dotnet/api/microsoft.aspnetcore.mvc.typefilterattribute?view=aspnetcore-3.1">TypeFilterAttribute</a> 來例化</p><pre tabindex=0><code>    public class LineVerifySignatureAttribute : TypeFilterAttribute
    {
     public LineVerifySignatureAttribute() : base(typeof(LineVerifySignatureFilter))
     {
     }
    }
</code></pre><p>在 Line Api Route 加上 [LineVerifySignature] 進行驗證，這樣程式就乾淨多了</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*JRVaHnY8AJMV3rTE0RDUHQ.png alt></p><h2 id=把-channel-secretaccess-token-移到-appsettingsjson>把 Channel Secret/Access Token 移到 appsettings.json<a hidden class=anchor aria-hidden=true href=#把-channel-secretaccess-token-移到-appsettingsjson>#</a></h2><p>通常我們會把這兩個資訊寫在設定檔，以便使用跟替換，在 .NET Core 可以使用 <a href="https://docs.microsoft.com/zh-tw/aspnet/core/fundamentals/configuration/options?view=aspnetcore-3.1">IOption </a>的方式來從設定檔注入</p><p>在 appsettings.json 增加區塊，放Channel Secret/Access Token</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*X6bBgY0Dm3VccFSFQrR_4Q.png alt></p><p>增加一個 LineSetting.cs，我們要用強型別來開發</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*YfIMbcox-L674b5vflih_g.png alt></p><p>startup.cs 增加 services.AddOptions()</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*5Xnwb7BnNzg9KTX58cf0gQ.png alt></p><p>回到前面建立的 LineVerifySignatureFilter.cs，注入 LineSetting及使用 ChannelSecret 即可完成</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/2000/1*rqNEpqI_-Sp7MfBcr8Iv-w.png alt></p><h1 id=懶人包本次學到了什麼>懶人包，本次學到了什麼?<a hidden class=anchor aria-hidden=true href=#懶人包本次學到了什麼>#</a></h1><ul><li>如何申請一個 Line Chatbot - 參考上方6步驟
<a href=https://developers.line.biz/en/>LINE Developers</a></li><li>如何建立一個 .NET Core Web Api 專案
<a href=https://jakeydocs.readthedocs.io/en/latest/tutorials/first-web-api.html#create-the-project>Building Your First Web API with ASP.NET Core MVC and Visual Studio</a>
<a href=https://docs.microsoft.com/zh-tw/dotnet/core/tools/dotnet-new>用 CLI 建立 .NET Core</a></li><li>如何將 Web API 跟 Line Server 連結起來
<a href=http://ngrok>Install ngrok by npm</a></li><li>如何驗證有效的Line Request
<a href=https://developers.line.biz/en/reference/messaging-api/#signature-validation>Line Signature Validation</a></li><li>如何使用 .NET Core 的 Filters & Attributes
<a href="https://docs.microsoft.com/zh-tw/aspnet/core/mvc/controllers/filters?view=aspnetcore-3.1">Filters in ASP.NET Core</a></li><li>如何在.NET Core讀取設定檔
<a href="https://docs.microsoft.com/zh-tw/aspnet/core/fundamentals/configuration/options?view=aspnetcore-3.1">Options pattern in ASP.NET Core</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://kyleap.github.io/tags/chatbot/>Chatbot</a></li></ul><nav class=paginav><a class=prev href=https://kyleap.github.io/it-ironman-line-chatbot-wedding-3/><span class=title>« Prev</span><br><span>用.NET Core 接收Line的訊息事件 (3)</span>
</a><a class=next href=https://kyleap.github.io/it-ironman-line-chatbot-wedding-1/><span class=title>Next »</span><br><span>用.NET Core與Line Bot製作婚禮機器人 (1)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kyleap.github.io/>凱哥打扣 | Kyle Studio</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>